---
title: "R Notebook"
output:
  pdf_document: default
  html_notebook: default
---

# Allocation methods
Let us start by defining functions for each allocation method

## Allocation methods that don't take into account covariates

### Random and Restricted randomisation

```{r}

## Allocation functions that don't take into account covariates

# Simple random selection
randomAllocation <- function(n, T){
  results = sample(1:T, n, replace = TRUE)
  return(results)
}

# Simple allocation based off Neyman Allocation
neymanKnown <- function(n, T, Results, p){
  q = 1 - p
  denom = sum(sqrt(p*q))
  p_calc = sqrt(p*q)/denom
  Allocation = sample(T, n, replace = TRUE, prob = p_calc)
  return(Allocation)
}

# Simple allocation based off RSIHR Allocation
RSIHRKnown <- function(n, T, Results, p){
  denom = sum(sqrt(p))
  p_calc = sqrt(p)/denom
  Allocation = sample(T, n, replace = TRUE, prob = p_calc)
  return(Allocation)
}

# Simple allocation based off Rosenberger Allocation
RosenbergerKnown <- function(n, T, Results, p){
  q = 1 - p
  denom = sum(p/q)
  p_calc = p/(q*denom)
  Allocation = sample(T, n, replace = TRUE, prob = p_calc)
  return(Allocation)
}


# Simple allocation based off Optimal adjusted
OptimalAdjustedKnown <- function(n, T, Results, p){
  q = 1 - p
  denom = sum(sqrt(p)*q)
  p_calc = sqrt(p)*q/denom
  Allocation = sample(T, n, replace = TRUE, prob = p_calc)
  return(Allocation)
}

# Efron biased coin design with alpha < 0.5 (alpha = 0.5 is simple random selection)
# Only works when T = 2
biasedCoinAllocation <- function(n, alpha){
  Allocation = rep(0,n) # biased coin design
  Si = rep(0,n)
  q = rep(0.5,n)
  for (i in seq(from = 1, to = n, by = 1)) {
    Allocation[i] = 2*(runif(1)<= q[i]) - 1
    if(i < n){
      Si[i+1] = sum(Allocation[1:i])/(i)
      if(Si[i+1] == 0){q[i+1] = 0.5}
      if(Si[i+1] < 0){q[i+1] = 1- alpha}
      if(Si[i+1] > 0){q[i+1] = alpha}
    }
  }
  Allocation = (Allocation + 3)/2
  CombinedResult = data.frame(Allocation = Allocation, Si = Si, q = q)
  return(CombinedResult)
}


```

## Response adaptive randomisation

### Coin based designs
```{r}
doublyBiasedCoinAllocation <- function(n, n0, T, Results){
  Allocation = rep(0,n) 
  q = rep(0.5,n) 
  #First initialise by assigning no to each treatment
  for (t in 1:T) {
    Allocation[n0*(t-1)+1:t*n0] = t
  }
  
  for (t in t*no+1:n) {
    q[i] = 
    Allocation[i] = 2 - (runif(1)<= q[i])
  
  return(Allocation)
  }
}

```


### Turn based and Gittins index
```{r}
# Play the Winner: If it is a success we continue with the same treatment otherwise we randomly select from all treatments
playTheWinner <- function(n, T, Results){
  Allocation = rep(0,n)
  winner = 0
  for (i in 1:T) {
    if (winner == 1) {
      Allocation[i] = Allocation[i-1]
    } else{
      Allocation[i] = sample(T,1)
    }
    Winner = Results[i, Allocation[i]]
  }
  return(Allocation)
}

# Play the winner randomised: Start with number of successes of each treatment (wA. wB). pA = wA / (wA + wB)
# Increment wA if treatment A succeeds or treatment B fails
# Similarly increment wB if treatment B succeeds or treatment A fails
# Two treatments only
playTheWinnerRandomised_2T <- function(n, Results, wA, wB){
  Allocation = rep(0,n)
  q = rep(0,n)
  for (i in 1:n) {
    q[i] = wA/(wA + wB)
    Allocation[i] = 2*(runif(1)<= q[i]) - 1
    Outcome = Results[i, Allocation[i]]
    if(( Outcome == 1 && Allocation[i] == 1) || (Outcome == 0 && Allocation[i] == 2) ){
      wA = wA + 1
    } else{ wB = wB + 1}
  }
  CombinedResult = data.frame(Allocation = Allocation, q = q)
  return(CombinedResult)
}

playTheWinnerRandomised <- function(n, Results, wA, wB){
  Allocation = rep(0,n)
  q = rep(0,n)
  
  return(Allocation)
}

GittinsIndex <- function(n, T, Results){
  Allocation = rep(0,n)
  G = rep(0,n)
  
  CombinedResult = data.frame(Allocation = Allocation, GittinsIndex =  G)
  return(CombinedResult)  
}
```

### Sequential estimation techniques Two Treatments
```{r}


neymanEstimated_binary <- function(n, n0, Results){
  Allocation = rep(0,n)
  T = 2
  #First initialise by assigning no to each treatment
  
   for (t in 1:T) {
    Allocation[(n0*(t-1)+1):(t*n0)] = t
  }
  
  for (i in (T*n0+1):n) {
    i
    pA = mean(Results[Allocation[1:(i-1)] == 1 ,1])
    qA = 1 - pA
    pB = mean(Results[Allocation[1:(i-1)] == 2 ,2])
    qB = 1 - pB
    R = sqrt((pA*qA)/(pB*qB))
    prob = R/(1+R)
    Allocation[i] = 2 - (runif(1) <= prob)
  
  }
  return(Allocation)
}

RSIHR_binary <- function(n, n0, Results){
  Allocation = rep(0,n)
  T = 2
  #First initialise by assigning no to each treatment
  
   for (t in 1:T) {
    Allocation[(n0*(t-1)+1):(t*n0)] = t
  }
  
  for (i in (T*n0+1):n) {
    i
    pA = mean(Results[Allocation[1:(i-1)] == 1 , 1])
    pB = mean(Results[Allocation[1:(i-1)] == 2 , 2])
    R = sqrt((pA)/(pB))
    prob = R/(1+R)
    Allocation[i] = 2 - (runif(1) <= prob)
  
  }
  return(Allocation)
}

ResponseAdaptive_Binary_1 <- function(n, n0, Results){
  T = 2
  Allocation = rep(0,n)
  for (t in 1:T) {
    Allocation[(n0*(t-1)+1):(t*n0)] = t
  }
  
  for (i in (T*n0+1):n) {
    i
    pA = mean(Results[Allocation[1:(i-1)] == 1 ,1])
    qA = 1 - pA
    pB = mean(Results[Allocation[1:(i-1)] == 2 ,2])
    qB = 1 - pB
    prob = ((pA/qA))/((pA/qA)+(pB/qB))
    Allocation[i] = 2 - (runif(1) <= prob)
  
  }
  return(Allocation)
}

ResponseAdaptive_Binary_2 <- function(n, n0, Results){
  Allocation = rep(0,n)
  T = 2
  #First initialise by assigning no to each treatment
  
   for (t in 1:T) {
    Allocation[(n0*(t-1)+1):(t*n0)] = t
  }
  
  for (i in (T*n0+1):n) {
    i
    pA = mean(Results[Allocation[1:(i-1)] == 1 ,1])
    qA = 1 - pA
    pB = mean(Results[Allocation[1:(i-1)] == 2 ,2])
    qB = 1 - pB
    R = sqrt((pA*qA^2)/(pB*qB^2))
    prob = R/(1+R)
    Allocation[i] = 2 - (runif(1) <= prob)
  
  }
  return(Allocation)
}
```

### Sequential estimation techniques Multiple Treatments - simple extensions
```{r}

neymanEstimated_multiple <- function(n, n0, T, Results){
  Allocation = rep(0,n)
  p = rep(0,T)
  q = rep(0,T)
  
  #First initialise by assigning no to each treatment
  for (t in 1:T) {
    Allocation[(n0*(t-1)+1):(t*n0)] = t
  }

    
  for (i in (T*n0+1):n) {
    for (j in 1:T) {
    p[j] = mean(Results[Allocation[1:(i-1)] == 1 ,j])
    q[j] = 1 - p[j]
    }
    denom = sum(sqrt(p*q))
    p_calc = sqrt(p*q)/denom
    Allocation[i] = sample(T,1, replace = TRUE, prob = p_calc)
  }
  return(Allocation)
}

RSIHR_multiple <- function(n, n0, T, Results){
  Allocation = rep(0,n)
  p = rep(0,T)
  
  #First initialise by assigning no to each treatment
  
   for (t in 1:T) {
    Allocation[(n0*(t-1)+1):(t*n0)] = t
  }
  
  for (i in (T*n0+1):n) {
    for (j in 1:T) {
      p[j] = mean(Results[Allocation[1:(i-1)] == 1 ,j])
    }
    denom = sum(sqrt(p))
    p_calc = sqrt(p)/denom
    Allocation[i] = sample(T,1, replace = TRUE, prob = p_calc)
  }
  return(Allocation)
}

Rosenberger_multiple <- function(n, n0, T, Results){
  Allocation = rep(0,n)
  p = rep(0,T)
  q = rep(0,T)
  
  for (t in 1:T) {
    Allocation[(n0*(t-1)+1):(t*n0)] = t
  }
  
  for (i in (T*n0+1):n) {
    for (j in 1:T) {
      p[j] = mean(Results[Allocation[1:(i-1)] == 1 ,j])
      q[j] = 1 - p[j]
    }
    denom = sum(p/q)
    p_calc = p/(q*denom)
    Allocation = sample(T, n, replace = TRUE, prob = p_calc)
  }
  return(Allocation)
}

OptimalAdjusted_multiple <- function(n, n0, Results){
  Allocation = rep(0,n)
  p = rep(0,T)
  q = rep(0,T)
  
  #First initialise by assigning no to each treatment
     for (t in 1:T) {
    Allocation[(n0*(t-1)+1):(t*n0)] = t
  }
  
  for (i in (T*n0+1):n) {
    for (j in 1:T) {
      p[j] = mean(Results[Allocation[1:(i-1)] == 1 ,j])
      q[j] = 1 - p[j]
    }
    denom = sum(sqrt(p)*q)
    p_calc = sqrt(p)*q/denom
    Allocation = sample(T, n, replace = TRUE, prob = p_calc)
  }
  return(Allocation)
}
```


## Allocation strategies that take into account covariates

### Sequential estimation
```{r}

## Allocation functions that take into account covariates
CARA1 <- function(n, n0, T, Z, Results){
  
}

CARA2 <- function(n, n0, T, Z, Results){
  
}

CARA3 <- function(n, n0, T, Z, Results){
  
}

```




# Simulation
setting up the problem

```{r}
n = 1000 # Number of subjects
n0 = 5

Z = rbinom(n,1,0.5) # Simulate covariates

SuccessProbs = c(0.2, 0.6)

SuccessProbs_Z = matrix(data = c(0.1, 0.3, 0.7, 0.1), nrow = 2, ncol = 2)
```

Now we can model different treatment allocation strategies

```{r}
# Results
T = length(SuccessProbs)
Results = matrix(0, nrow = n, ncol = T)

for (i in 1:T) {
  Results[ , i] = rbinom(n, 1, SuccessProbs[i]) 
}


# Pure random
Allocation_random = randomAllocation(n, T)
  
# Biased Coin
Allocation_biasedCoin = biasedCoinAllocation(n, 1/3)

```

```{r}
# Play the winner
Allocation_playTheWinner = playTheWinner(n, T, Results)
Allocation_playTheWinner_Randomised = playTheWinnerRandomised_2T(n, Results, 1, 1)

# Neyman Allocations
Allocation_neyamn_known = neymanKnown(n, T, Results, SuccessProbs)
Allocation_neyamn_estimated = neymanEstimated_binary(n, n0, Results)
Allocation_RSHIR_binary = RSIHR_binary(n, n0, Results)

Allocation_ResponseAdaptive_Binary_1 = ResponseAdaptive_Binary_1(n, n0, Results)
Allocation_ResponseAdaptive_Binary_2 = ResponseAdaptive_Binary_2(n, n0, Results)
```

```{r}
table(Allocation_random)
table(Allocation_biasedCoin[,1])
table(Allocation_playTheWinner)
table(Allocation_neyamn_known)
table(Allocation_neyamn_estimated)
table(Allocation_RSHIR_binary)
table(Allocation_ResponseAdaptive_Binary_1)
table(Allocation_ResponseAdaptive_Binary_2)
```
